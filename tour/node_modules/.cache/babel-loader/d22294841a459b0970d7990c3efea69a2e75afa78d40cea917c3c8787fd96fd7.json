{"ast":null,"code":"import $ckyCP$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { useLayoutEffect as $ckyCP$useLayoutEffect, focusWithoutScrolling as $ckyCP$focusWithoutScrolling, mergeProps as $ckyCP$mergeProps } from \"@react-aria/utils\";\nimport { useHover as $ckyCP$useHover, useFocusWithin as $ckyCP$useFocusWithin, getInteractionModality as $ckyCP$getInteractionModality } from \"@react-aria/interactions\";\nimport { useRef as $ckyCP$useRef, useEffect as $ckyCP$useEffect } from \"react\";\nimport { useLandmark as $ckyCP$useLandmark } from \"@react-aria/landmark\";\nimport { useLocalizedStringFormatter as $ckyCP$useLocalizedStringFormatter } from \"@react-aria/i18n\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nfunction $6cc546b19ee7130a$export$b8cbbb20a51697de(props, state, ref) {\n  let stringFormatter = (0, $ckyCP$useLocalizedStringFormatter)((0, $parcel$interopDefault($ckyCP$intlStringsmodulejs)), '@react-aria/toast');\n  let {\n    landmarkProps: landmarkProps\n  } = (0, $ckyCP$useLandmark)({\n    role: 'region',\n    'aria-label': props['aria-label'] || stringFormatter.format('notifications', {\n      count: state.visibleToasts.length\n    })\n  }, ref);\n  let {\n    hoverProps: hoverProps\n  } = (0, $ckyCP$useHover)({\n    onHoverStart: state.pauseAll,\n    onHoverEnd: state.resumeAll\n  });\n  // Manage focus within the toast region.\n  // If a focused containing toast is removed, move focus to the next toast, or the previous toast if there is no next toast.\n  // We might be making an assumption with how this works if someone implements the priority queue differently, or\n  // if they only show one toast at a time.\n  let toasts = (0, $ckyCP$useRef)([]);\n  let prevVisibleToasts = (0, $ckyCP$useRef)(state.visibleToasts);\n  let focusedToast = (0, $ckyCP$useRef)(null);\n  (0, $ckyCP$useLayoutEffect)(() => {\n    // If no toast has focus, then don't do anything.\n    if (focusedToast.current === -1 || state.visibleToasts.length === 0 || !ref.current) {\n      toasts.current = [];\n      prevVisibleToasts.current = state.visibleToasts;\n      return;\n    }\n    toasts.current = [...ref.current.querySelectorAll('[role=\"alertdialog\"]')];\n    // If the visible toasts haven't changed, we don't need to do anything.\n    if (prevVisibleToasts.current.length === state.visibleToasts.length && state.visibleToasts.every((t, i) => t.key === prevVisibleToasts.current[i].key)) {\n      prevVisibleToasts.current = state.visibleToasts;\n      return;\n    }\n    // Get a list of all toasts by index and add info if they are removed.\n    let allToasts = prevVisibleToasts.current.map((t, i) => ({\n      ...t,\n      i: i,\n      isRemoved: !state.visibleToasts.some(t2 => t.key === t2.key)\n    }));\n    let removedFocusedToastIndex = allToasts.findIndex(t => t.i === focusedToast.current);\n    // If the focused toast was removed, focus the next or previous toast.\n    if (removedFocusedToastIndex > -1) {\n      let i = 0;\n      let nextToast;\n      let prevToast;\n      while (i <= removedFocusedToastIndex) {\n        if (!allToasts[i].isRemoved) prevToast = Math.max(0, i - 1);\n        i++;\n      }\n      while (i < allToasts.length) {\n        if (!allToasts[i].isRemoved) {\n          nextToast = i - 1;\n          break;\n        }\n        i++;\n      }\n      // in the case where it's one toast at a time, both will be undefined, but we know the index must be 0\n      if (prevToast === undefined && nextToast === undefined) prevToast = 0;\n      // prioritize going to newer toasts\n      if (prevToast >= 0 && prevToast < toasts.current.length) (0, $ckyCP$focusWithoutScrolling)(toasts.current[prevToast]);else if (nextToast >= 0 && nextToast < toasts.current.length) (0, $ckyCP$focusWithoutScrolling)(toasts.current[nextToast]);\n    }\n    prevVisibleToasts.current = state.visibleToasts;\n  }, [state.visibleToasts, ref]);\n  let lastFocused = (0, $ckyCP$useRef)(null);\n  let {\n    focusWithinProps: focusWithinProps\n  } = (0, $ckyCP$useFocusWithin)({\n    onFocusWithin: e => {\n      state.pauseAll();\n      lastFocused.current = e.relatedTarget;\n    },\n    onBlurWithin: () => {\n      state.resumeAll();\n      lastFocused.current = null;\n    }\n  });\n  // When the number of visible toasts becomes 0 or the region unmounts,\n  // restore focus to the last element that had focus before the user moved focus\n  // into the region. FocusScope restore focus doesn't update whenever the focus\n  // moves in, it only happens once, so we correct it.\n  // Because we're in a hook, we can't control if the user unmounts or not.\n  (0, $ckyCP$useEffect)(() => {\n    if (state.visibleToasts.length === 0 && lastFocused.current && document.body.contains(lastFocused.current)) {\n      if ((0, $ckyCP$getInteractionModality)() === 'pointer') (0, $ckyCP$focusWithoutScrolling)(lastFocused.current);else lastFocused.current.focus();\n      lastFocused.current = null;\n    }\n  }, [ref, state.visibleToasts.length]);\n  (0, $ckyCP$useEffect)(() => {\n    return () => {\n      if (lastFocused.current && document.body.contains(lastFocused.current)) {\n        if ((0, $ckyCP$getInteractionModality)() === 'pointer') (0, $ckyCP$focusWithoutScrolling)(lastFocused.current);else lastFocused.current.focus();\n        lastFocused.current = null;\n      }\n    };\n  }, [ref]);\n  return {\n    regionProps: (0, $ckyCP$mergeProps)(landmarkProps, hoverProps, focusWithinProps, {\n      tabIndex: -1,\n      // Mark the toast region as a \"top layer\", so that it:\n      //   - is not aria-hidden when opening an overlay\n      //   - allows focus even outside a containing focus scope\n      //   - doesn’t dismiss overlays when clicking on it, even though it is outside\n      // @ts-ignore\n      'data-react-aria-top-layer': true,\n      // listen to focus events separate from focuswithin because that will only fire once\n      // and we need to follow all focus changes\n      onFocus: e => {\n        let target = e.target.closest('[role=\"alertdialog\"]');\n        focusedToast.current = toasts.current.findIndex(t => t === target);\n      },\n      onBlur: () => {\n        focusedToast.current = -1;\n      }\n    })\n  };\n}\nexport { $6cc546b19ee7130a$export$b8cbbb20a51697de as useToastRegion };","map":{"version":3,"names":["$6cc546b19ee7130a$export$b8cbbb20a51697de","props","state","ref","stringFormatter","$ckyCP$useLocalizedStringFormatter","$parcel$interopDefault","$ckyCP$intlStringsmodulejs","landmarkProps","$ckyCP$useLandmark","role","format","count","visibleToasts","length","hoverProps","$ckyCP$useHover","onHoverStart","pauseAll","onHoverEnd","resumeAll","toasts","$ckyCP$useRef","prevVisibleToasts","focusedToast","$ckyCP$useLayoutEffect","current","querySelectorAll","every","t","i","key","allToasts","map","isRemoved","some","t2","removedFocusedToastIndex","findIndex","nextToast","prevToast","Math","max","undefined","$ckyCP$focusWithoutScrolling","lastFocused","focusWithinProps","$ckyCP$useFocusWithin","onFocusWithin","e","relatedTarget","onBlurWithin","$ckyCP$useEffect","document","body","contains","$ckyCP$getInteractionModality","focus","regionProps","$ckyCP$mergeProps","tabIndex","onFocus","target","closest","onBlur"],"sources":["/media/Akunamatata/Course Project/tour/node_modules/@react-aria/toast/dist/packages/@react-aria/toast/src/useToastRegion.ts"],"sourcesContent":["import {AriaLabelingProps, DOMAttributes, FocusableElement, RefObject} from '@react-types/shared';\nimport {focusWithoutScrolling, mergeProps, useLayoutEffect} from '@react-aria/utils';\nimport {getInteractionModality, useFocusWithin, useHover} from '@react-aria/interactions';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {ToastState} from '@react-stately/toast';\nimport {useEffect, useRef} from 'react';\nimport {useLandmark} from '@react-aria/landmark';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface AriaToastRegionProps extends AriaLabelingProps {\n  /**\n   * An accessibility label for the toast region.\n   * @default \"Notifications\"\n   */\n  'aria-label'?: string\n}\n\nexport interface ToastRegionAria {\n  /** Props for the landmark region element. */\n  regionProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a toast region containing one or more toasts.\n * Toasts display brief, temporary notifications of actions, errors, or other events in an application.\n */\nexport function useToastRegion<T>(props: AriaToastRegionProps, state: ToastState<T>, ref: RefObject<HTMLElement | null>): ToastRegionAria {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/toast');\n  let {landmarkProps} = useLandmark({\n    role: 'region',\n    'aria-label': props['aria-label'] || stringFormatter.format('notifications', {count: state.visibleToasts.length})\n  }, ref);\n\n  let {hoverProps} = useHover({\n    onHoverStart: state.pauseAll,\n    onHoverEnd: state.resumeAll\n  });\n\n  // Manage focus within the toast region.\n  // If a focused containing toast is removed, move focus to the next toast, or the previous toast if there is no next toast.\n  // We might be making an assumption with how this works if someone implements the priority queue differently, or\n  // if they only show one toast at a time.\n  let toasts = useRef<FocusableElement[]>([]);\n  let prevVisibleToasts = useRef(state.visibleToasts);\n  let focusedToast = useRef<number | null>(null);\n  useLayoutEffect(() => {\n    // If no toast has focus, then don't do anything.\n    if (focusedToast.current === -1 || state.visibleToasts.length === 0 || !ref.current) {\n      toasts.current = [];\n      prevVisibleToasts.current = state.visibleToasts;\n      return;\n    }\n    toasts.current = [...ref.current.querySelectorAll('[role=\"alertdialog\"]')] as FocusableElement[];\n    // If the visible toasts haven't changed, we don't need to do anything.\n    if (prevVisibleToasts.current.length === state.visibleToasts.length\n      && state.visibleToasts.every((t, i) => t.key === prevVisibleToasts.current[i].key)) {\n      prevVisibleToasts.current = state.visibleToasts;\n      return;\n    }\n    // Get a list of all toasts by index and add info if they are removed.\n    let allToasts = prevVisibleToasts.current\n      .map((t, i) => ({\n        ...t,\n        i,\n        isRemoved: !state.visibleToasts.some(t2 => t.key === t2.key)\n      }));\n\n    let removedFocusedToastIndex = allToasts.findIndex(t => t.i === focusedToast.current);\n\n    // If the focused toast was removed, focus the next or previous toast.\n    if (removedFocusedToastIndex > -1) {\n      let i = 0;\n      let nextToast;\n      let prevToast;\n      while (i <= removedFocusedToastIndex) {\n        if (!allToasts[i].isRemoved) {\n          prevToast = Math.max(0, i - 1);\n        }\n        i++;\n      }\n      while (i < allToasts.length) {\n        if (!allToasts[i].isRemoved) {\n          nextToast = i - 1;\n          break;\n        }\n        i++;\n      }\n\n      // in the case where it's one toast at a time, both will be undefined, but we know the index must be 0\n      if (prevToast === undefined && nextToast === undefined) {\n        prevToast = 0;\n      }\n\n      // prioritize going to newer toasts\n      if (prevToast >= 0 && prevToast < toasts.current.length) {\n        focusWithoutScrolling(toasts.current[prevToast]);\n      } else if (nextToast >= 0 && nextToast < toasts.current.length) {\n        focusWithoutScrolling(toasts.current[nextToast]);\n      }\n    }\n\n    prevVisibleToasts.current = state.visibleToasts;\n  }, [state.visibleToasts, ref]);\n\n  let lastFocused = useRef<FocusableElement | null>(null);\n  let {focusWithinProps} = useFocusWithin({\n    onFocusWithin: (e) => {\n      state.pauseAll();\n      lastFocused.current = e.relatedTarget as FocusableElement;\n    },\n    onBlurWithin: () => {\n      state.resumeAll();\n      lastFocused.current = null;\n    }\n  });\n\n  // When the number of visible toasts becomes 0 or the region unmounts,\n  // restore focus to the last element that had focus before the user moved focus\n  // into the region. FocusScope restore focus doesn't update whenever the focus\n  // moves in, it only happens once, so we correct it.\n  // Because we're in a hook, we can't control if the user unmounts or not.\n  useEffect(() => {\n    if (state.visibleToasts.length === 0 && lastFocused.current && document.body.contains(lastFocused.current)) {\n      if (getInteractionModality() === 'pointer') {\n        focusWithoutScrolling(lastFocused.current);\n      } else {\n        lastFocused.current.focus();\n      }\n      lastFocused.current = null;\n    }\n  }, [ref, state.visibleToasts.length]);\n\n  useEffect(() => {\n    return () => {\n      if (lastFocused.current && document.body.contains(lastFocused.current)) {\n        if (getInteractionModality() === 'pointer') {\n          focusWithoutScrolling(lastFocused.current);\n        } else {\n          lastFocused.current.focus();\n        }\n        lastFocused.current = null;\n      }\n    };\n  }, [ref]);\n\n  return {\n    regionProps: mergeProps(landmarkProps, hoverProps, focusWithinProps, {\n      tabIndex: -1,\n      // Mark the toast region as a \"top layer\", so that it:\n      //   - is not aria-hidden when opening an overlay\n      //   - allows focus even outside a containing focus scope\n      //   - doesn’t dismiss overlays when clicking on it, even though it is outside\n      // @ts-ignore\n      'data-react-aria-top-layer': true,\n      // listen to focus events separate from focuswithin because that will only fire once\n      // and we need to follow all focus changes\n      onFocus: (e) => {\n        let target = e.target.closest('[role=\"alertdialog\"]');\n        focusedToast.current = toasts.current.findIndex(t => t === target);\n      },\n      onBlur: () => {\n        focusedToast.current = -1;\n      }\n    })\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}