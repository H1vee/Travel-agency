{"ast":null,"code":"import { useMemo as $cNx9A$useMemo, useCallback as $cNx9A$useCallback } from \"react\";\nimport { useSyncExternalStore as $cNx9A$useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $77b352cf12efcf73$export$c7b26b20d3ced9c5(props = {}) {\n  let {\n    maxVisibleToasts = 1,\n    hasExitAnimation = false\n  } = props;\n  let queue = (0, $cNx9A$useMemo)(() => new $77b352cf12efcf73$export$f1f8569633bbbec4({\n    maxVisibleToasts: maxVisibleToasts,\n    hasExitAnimation: hasExitAnimation\n  }), [maxVisibleToasts, hasExitAnimation]);\n  return $77b352cf12efcf73$export$84726ef35ca2129a(queue);\n}\nfunction $77b352cf12efcf73$export$84726ef35ca2129a(queue) {\n  let subscribe = (0, $cNx9A$useCallback)(fn => queue.subscribe(fn), [queue]);\n  let getSnapshot = (0, $cNx9A$useCallback)(() => queue.visibleToasts, [queue]);\n  let visibleToasts = (0, $cNx9A$useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n  return {\n    visibleToasts: visibleToasts,\n    add: (content, options) => queue.add(content, options),\n    close: key => queue.close(key),\n    remove: key => queue.remove(key),\n    pauseAll: () => queue.pauseAll(),\n    resumeAll: () => queue.resumeAll()\n  };\n}\nclass $77b352cf12efcf73$export$f1f8569633bbbec4 {\n  /** Subscribes to updates to the visible toasts. */subscribe(fn) {\n    this.subscriptions.add(fn);\n    return () => this.subscriptions.delete(fn);\n  }\n  /** Adds a new toast to the queue. */\n  add(content, options = {}) {\n    let toastKey = Math.random().toString(36);\n    let toast = {\n      ...options,\n      content: content,\n      key: toastKey,\n      timer: options.timeout ? new $77b352cf12efcf73$var$Timer(() => this.close(toastKey), options.timeout) : undefined\n    };\n    let low = 0;\n    let high = this.queue.length;\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      if ((toast.priority || 0) > (this.queue[mid].priority || 0)) high = mid;else low = mid + 1;\n    }\n    this.queue.splice(low, 0, toast);\n    toast.animation = low < this.maxVisibleToasts ? 'entering' : 'queued';\n    let i = this.maxVisibleToasts;\n    while (i < this.queue.length) this.queue[i++].animation = 'queued';\n    this.updateVisibleToasts({\n      action: 'add'\n    });\n    return toastKey;\n  }\n  /**\n  * Closes a toast. If `hasExitAnimation` is true, the toast\n  * transitions to an \"exiting\" state instead of being removed immediately.\n  */\n  close(key) {\n    let index = this.queue.findIndex(t => t.key === key);\n    if (index >= 0) {\n      var _this_queue_index_onClose, _this_queue_index;\n      (_this_queue_index_onClose = (_this_queue_index = this.queue[index]).onClose) === null || _this_queue_index_onClose === void 0 ? void 0 : _this_queue_index_onClose.call(_this_queue_index);\n      this.queue.splice(index, 1);\n    }\n    this.updateVisibleToasts({\n      action: 'close',\n      key: key\n    });\n  }\n  /** Removes a toast from the visible toasts after an exiting animation. */\n  remove(key) {\n    this.updateVisibleToasts({\n      action: 'remove',\n      key: key\n    });\n  }\n  updateVisibleToasts(options) {\n    let {\n      action: action,\n      key: key\n    } = options;\n    let toasts = this.queue.slice(0, this.maxVisibleToasts);\n    if (action === 'add' && this.hasExitAnimation) {\n      let prevToasts = this.visibleToasts.filter(t => !toasts.some(t2 => t.key === t2.key)).map(t => ({\n        ...t,\n        animation: 'exiting'\n      }));\n      this.visibleToasts = prevToasts.concat(toasts).sort((a, b) => {\n        var _b_priority, _a_priority;\n        return ((_b_priority = b.priority) !== null && _b_priority !== void 0 ? _b_priority : 0) - ((_a_priority = a.priority) !== null && _a_priority !== void 0 ? _a_priority : 0);\n      });\n    } else if (action === 'close' && this.hasExitAnimation)\n      // Cause a rerender to happen for exit animation\n      this.visibleToasts = this.visibleToasts.map(t => {\n        if (t.key !== key) return t;else return {\n          ...t,\n          animation: 'exiting'\n        };\n      });else this.visibleToasts = toasts;\n    for (let fn of this.subscriptions) fn();\n  }\n  /** Pauses the timers for all visible toasts. */\n  pauseAll() {\n    for (let toast of this.visibleToasts) if (toast.timer) toast.timer.pause();\n  }\n  /** Resumes the timers for all visible toasts. */\n  resumeAll() {\n    for (let toast of this.visibleToasts) if (toast.timer) toast.timer.resume();\n  }\n  constructor(options) {\n    this.queue = [];\n    this.subscriptions = new Set();\n    /** The currently visible toasts. */\n    this.visibleToasts = [];\n    var _options_maxVisibleToasts;\n    this.maxVisibleToasts = (_options_maxVisibleToasts = options === null || options === void 0 ? void 0 : options.maxVisibleToasts) !== null && _options_maxVisibleToasts !== void 0 ? _options_maxVisibleToasts : 1;\n    var _options_hasExitAnimation;\n    this.hasExitAnimation = (_options_hasExitAnimation = options === null || options === void 0 ? void 0 : options.hasExitAnimation) !== null && _options_hasExitAnimation !== void 0 ? _options_hasExitAnimation : false;\n  }\n}\nclass $77b352cf12efcf73$var$Timer {\n  reset(delay) {\n    this.remaining = delay;\n    this.resume();\n  }\n  pause() {\n    if (this.timerId == null) return;\n    clearTimeout(this.timerId);\n    this.timerId = null;\n    this.remaining -= Date.now() - this.startTime;\n  }\n  resume() {\n    if (this.remaining <= 0) return;\n    this.startTime = Date.now();\n    this.timerId = setTimeout(() => {\n      this.timerId = null;\n      this.remaining = 0;\n      this.callback();\n    }, this.remaining);\n  }\n  constructor(callback, delay) {\n    this.startTime = null;\n    this.remaining = delay;\n    this.callback = callback;\n  }\n}\nexport { $77b352cf12efcf73$export$c7b26b20d3ced9c5 as useToastState, $77b352cf12efcf73$export$f1f8569633bbbec4 as ToastQueue, $77b352cf12efcf73$export$84726ef35ca2129a as useToastQueue };","map":{"version":3,"names":["$77b352cf12efcf73$export$c7b26b20d3ced9c5","props","maxVisibleToasts","hasExitAnimation","queue","$cNx9A$useMemo","$77b352cf12efcf73$export$f1f8569633bbbec4","$77b352cf12efcf73$export$84726ef35ca2129a","subscribe","$cNx9A$useCallback","fn","getSnapshot","visibleToasts","$cNx9A$useSyncExternalStore","add","content","options","close","key","remove","pauseAll","resumeAll","subscriptions","delete","toastKey","Math","random","toString","toast","timer","timeout","$77b352cf12efcf73$var$Timer","undefined","low","high","length","mid","floor","priority","splice","animation","i","updateVisibleToasts","action","index","findIndex","t","_this_queue_index_onClose","_this_queue_index","onClose","call","toasts","slice","prevToasts","filter","some","t2","map","concat","sort","a","b","_b_priority","_a_priority","pause","resume","constructor","Set","_options_maxVisibleToasts","_options_hasExitAnimation","reset","delay","remaining","timerId","clearTimeout","Date","now","startTime","setTimeout","callback"],"sources":["/media/Akunamatata/Course Project/tour/node_modules/@react-stately/toast/dist/packages/@react-stately/toast/src/useToastState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useMemo} from 'react';\n// Shim to support React 17 and below.\nimport {useSyncExternalStore} from 'use-sync-external-store/shim/index.js';\n\nexport interface ToastStateProps {\n  /** The maximum number of toasts to display at a time. */\n  maxVisibleToasts?: number,\n  /**\n   * Whether toasts have an exit animation. If true, toasts are not\n   * removed immediately but transition into an \"exiting\" state instead.\n   * Once the animation is complete, call the `remove` function.\n   */\n  hasExitAnimation?: boolean\n}\n\nexport interface ToastOptions {\n  /** Handler that is called when the toast is closed, either by the user or after a timeout. */\n  onClose?: () => void,\n  /** A timeout to automatically close the toast after, in milliseconds. */\n  timeout?: number,\n  /** The priority of the toast relative to other toasts. Larger numbers indicate higher priority. */\n  priority?: number\n}\n\nexport interface QueuedToast<T> extends ToastOptions {\n  /** The content of the toast. */\n  content: T,\n  /** A unique key for the toast. */\n  key: string,\n  /** A timer for the toast, if a timeout was set. */\n  timer?: Timer,\n  /** The current animation state for the toast. */\n  animation?: 'entering' | 'queued' | 'exiting' | null\n}\n\nexport interface ToastState<T> {\n  /** Adds a new toast to the queue. */\n  add(content: T, options?: ToastOptions): string,\n  /**\n   * Closes a toast. If `hasExitAnimation` is true, the toast\n   * transitions to an \"exiting\" state instead of being removed immediately.\n   */\n  close(key: string): void,\n  /** Removes a toast from the visible toasts after an exiting animation. */\n  remove(key: string): void,\n  /** Pauses the timers for all visible toasts. */\n  pauseAll(): void,\n  /** Resumes the timers for all visible toasts. */\n  resumeAll(): void,\n  /** The visible toasts. */\n  visibleToasts: QueuedToast<T>[]\n}\n\n/**\n * Provides state management for a toast queue. Toasts display brief, temporary notifications\n * of actions, errors, or other events in an application.\n */\nexport function useToastState<T>(props: ToastStateProps = {}): ToastState<T> {\n  let {maxVisibleToasts = 1, hasExitAnimation = false} = props;\n  let queue = useMemo(() => new ToastQueue<T>({maxVisibleToasts, hasExitAnimation}), [maxVisibleToasts, hasExitAnimation]);\n  return useToastQueue(queue);\n}\n\n/**\n * Subscribes to a provided toast queue and provides methods to update it.\n */\nexport function useToastQueue<T>(queue: ToastQueue<T>): ToastState<T> {\n  let subscribe = useCallback(fn => queue.subscribe(fn), [queue]);\n  let getSnapshot = useCallback(() => queue.visibleToasts, [queue]);\n  let visibleToasts = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n\n  return {\n    visibleToasts,\n    add: (content, options) => queue.add(content, options),\n    close: key => queue.close(key),\n    remove: key => queue.remove(key),\n    pauseAll: () => queue.pauseAll(),\n    resumeAll: () => queue.resumeAll()\n  };\n}\n\n/**\n * A ToastQueue is a priority queue of toasts.\n */\nexport class ToastQueue<T> {\n  private queue: QueuedToast<T>[] = [];\n  private subscriptions: Set<() => void> = new Set();\n  private maxVisibleToasts: number;\n  private hasExitAnimation: boolean;\n  /** The currently visible toasts. */\n  visibleToasts: QueuedToast<T>[] = [];\n\n  constructor(options?: ToastStateProps) {\n    this.maxVisibleToasts = options?.maxVisibleToasts ?? 1;\n    this.hasExitAnimation = options?.hasExitAnimation ?? false;\n  }\n\n  /** Subscribes to updates to the visible toasts. */\n  subscribe(fn: () => void) {\n    this.subscriptions.add(fn);\n    return () => this.subscriptions.delete(fn);\n  }\n\n  /** Adds a new toast to the queue. */\n  add(content: T, options: ToastOptions = {}) {\n    let toastKey = Math.random().toString(36);\n    let toast: QueuedToast<T> = {\n      ...options,\n      content,\n      key: toastKey,\n      timer: options.timeout ? new Timer(() => this.close(toastKey), options.timeout) : undefined\n    };\n\n    let low = 0;\n    let high = this.queue.length;\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      if ((toast.priority || 0) > (this.queue[mid].priority || 0)) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    this.queue.splice(low, 0, toast);\n\n    toast.animation = low < this.maxVisibleToasts ? 'entering' : 'queued';\n    let i = this.maxVisibleToasts;\n    while (i < this.queue.length) {\n      this.queue[i++].animation = 'queued';\n    }\n\n    this.updateVisibleToasts({action: 'add'});\n    return toastKey;\n  }\n\n  /**\n   * Closes a toast. If `hasExitAnimation` is true, the toast\n   * transitions to an \"exiting\" state instead of being removed immediately.\n   */\n  close(key: string) {\n    let index = this.queue.findIndex(t => t.key === key);\n    if (index >= 0) {\n      this.queue[index].onClose?.();\n      this.queue.splice(index, 1);\n    }\n\n    this.updateVisibleToasts({action: 'close', key});\n  }\n\n  /** Removes a toast from the visible toasts after an exiting animation. */\n  remove(key: string) {\n    this.updateVisibleToasts({action: 'remove', key});\n  }\n\n  private updateVisibleToasts(options: {action: 'add' | 'close' | 'remove', key?: string}) {\n    let {action, key} = options;\n    let toasts = this.queue.slice(0, this.maxVisibleToasts);\n\n    if (action === 'add' && this.hasExitAnimation) {\n      let prevToasts: QueuedToast<T>[] = this.visibleToasts\n        .filter(t => !toasts.some(t2 => t.key === t2.key))\n        .map(t => ({...t, animation: 'exiting'}));\n      this.visibleToasts = prevToasts.concat(toasts).sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));\n    } else if (action === 'close' && this.hasExitAnimation) {\n      // Cause a rerender to happen for exit animation\n      this.visibleToasts = this.visibleToasts.map(t => {\n        if (t.key !== key) {\n          return t;\n        } else {\n          return {...t, animation: 'exiting'};\n        }\n      });\n    } else {\n      this.visibleToasts = toasts;\n    }\n\n    for (let fn of this.subscriptions) {\n      fn();\n    }\n  }\n\n  /** Pauses the timers for all visible toasts. */\n  pauseAll() {\n    for (let toast of this.visibleToasts) {\n      if (toast.timer) {\n        toast.timer.pause();\n      }\n    }\n  }\n\n  /** Resumes the timers for all visible toasts. */\n  resumeAll() {\n    for (let toast of this.visibleToasts) {\n      if (toast.timer) {\n        toast.timer.resume();\n      }\n    }\n  }\n}\n\nclass Timer {\n  private timerId;\n  private startTime: number | null = null;\n  private remaining: number;\n  private callback: () => void;\n\n  constructor(callback: () => void, delay: number) {\n    this.remaining = delay;\n    this.callback = callback;\n  }\n\n  reset(delay: number) {\n    this.remaining = delay;\n    this.resume();\n  }\n\n  pause() {\n    if (this.timerId == null) {\n      return;\n    }\n\n    clearTimeout(this.timerId);\n    this.timerId = null;\n    this.remaining -= Date.now() - this.startTime!;\n  }\n\n  resume() {\n    if (this.remaining <= 0) {\n      return;\n    }\n\n    this.startTime = Date.now();\n    this.timerId = setTimeout(() => {\n      this.timerId = null;\n      this.remaining = 0;\n      this.callback();\n    }, this.remaining);\n  }\n}\n"],"mappings":";;;AAAA;;;;;;;;;;;;AAqEO,SAASA,0CAAiBC,KAAA,GAAyB,CAAC,CAAC;EAC1D,IAAI;IAACC,gBAAA,GAAmB;IAAGC,gBAAA,GAAmB;EAAA,CAAM,GAAGF,KAAA;EACvD,IAAIG,KAAA,GAAQ,IAAAC,cAAM,EAAE,MAAM,IAAIC,yCAAA,CAAc;sBAACJ,gBAAA;sBAAkBC;EAAgB,IAAI,CAACD,gBAAA,EAAkBC,gBAAA,CAAiB;EACvH,OAAOI,yCAAA,CAAcH,KAAA;AACvB;AAKO,SAASG,0CAAiBH,KAAoB;EACnD,IAAII,SAAA,GAAY,IAAAC,kBAAU,EAAEC,EAAA,IAAMN,KAAA,CAAMI,SAAS,CAACE,EAAA,GAAK,CAACN,KAAA,CAAM;EAC9D,IAAIO,WAAA,GAAc,IAAAF,kBAAU,EAAE,MAAML,KAAA,CAAMQ,aAAa,EAAE,CAACR,KAAA,CAAM;EAChE,IAAIQ,aAAA,GAAgB,IAAAC,2BAAmB,EAAEL,SAAA,EAAWG,WAAA,EAAaA,WAAA;EAEjE,OAAO;mBACLC,aAAA;IACAE,GAAA,EAAKA,CAACC,OAAA,EAASC,OAAA,KAAYZ,KAAA,CAAMU,GAAG,CAACC,OAAA,EAASC,OAAA;IAC9CC,KAAA,EAAOC,GAAA,IAAOd,KAAA,CAAMa,KAAK,CAACC,GAAA;IAC1BC,MAAA,EAAQD,GAAA,IAAOd,KAAA,CAAMe,MAAM,CAACD,GAAA;IAC5BE,QAAA,EAAUA,CAAA,KAAMhB,KAAA,CAAMgB,QAAQ;IAC9BC,SAAA,EAAWA,CAAA,KAAMjB,KAAA,CAAMiB,SAAS;EAClC;AACF;AAKO,MAAMf,yCAAA;EAaX,mDACAE,UAAUE,EAAc,EAAE;IACxB,IAAI,CAACY,aAAa,CAACR,GAAG,CAACJ,EAAA;IACvB,OAAO,MAAM,IAAI,CAACY,aAAa,CAACC,MAAM,CAACb,EAAA;EACzC;EAEA;EACAI,IAAIC,OAAU,EAAEC,OAAA,GAAwB,CAAC,CAAC,EAAE;IAC1C,IAAIQ,QAAA,GAAWC,IAAA,CAAKC,MAAM,GAAGC,QAAQ,CAAC;IACtC,IAAIC,KAAA,GAAwB;MAC1B,GAAGZ,OAAO;eACVD,OAAA;MACAG,GAAA,EAAKM,QAAA;MACLK,KAAA,EAAOb,OAAA,CAAQc,OAAO,GAAG,IAAIC,2BAAA,CAAM,MAAM,IAAI,CAACd,KAAK,CAACO,QAAA,GAAWR,OAAA,CAAQc,OAAO,IAAIE;IACpF;IAEA,IAAIC,GAAA,GAAM;IACV,IAAIC,IAAA,GAAO,IAAI,CAAC9B,KAAK,CAAC+B,MAAM;IAC5B,OAAOF,GAAA,GAAMC,IAAA,EAAM;MACjB,IAAIE,GAAA,GAAMX,IAAA,CAAKY,KAAK,CAAC,CAACJ,GAAA,GAAMC,IAAG,IAAK;MACpC,IAAI,CAACN,KAAA,CAAMU,QAAQ,IAAI,MAAM,IAAI,CAAClC,KAAK,CAACgC,GAAA,CAAI,CAACE,QAAQ,IAAI,IACvDJ,IAAA,GAAOE,GAAA,MAEPH,GAAA,GAAMG,GAAA,GAAM;IAEhB;IAEA,IAAI,CAAChC,KAAK,CAACmC,MAAM,CAACN,GAAA,EAAK,GAAGL,KAAA;IAE1BA,KAAA,CAAMY,SAAS,GAAGP,GAAA,GAAM,IAAI,CAAC/B,gBAAgB,GAAG,aAAa;IAC7D,IAAIuC,CAAA,GAAI,IAAI,CAACvC,gBAAgB;IAC7B,OAAOuC,CAAA,GAAI,IAAI,CAACrC,KAAK,CAAC+B,MAAM,EAC1B,IAAI,CAAC/B,KAAK,CAACqC,CAAA,GAAI,CAACD,SAAS,GAAG;IAG9B,IAAI,CAACE,mBAAmB,CAAC;MAACC,MAAA,EAAQ;IAAK;IACvC,OAAOnB,QAAA;EACT;EAEA;;;;EAIAP,MAAMC,GAAW,EAAE;IACjB,IAAI0B,KAAA,GAAQ,IAAI,CAACxC,KAAK,CAACyC,SAAS,CAACC,CAAA,IAAKA,CAAA,CAAE5B,GAAG,KAAKA,GAAA;IAChD,IAAI0B,KAAA,IAAS,GAAG;UACdG,yBAAA,EAAAC,iBAAA;OAAAD,yBAAA,IAAAC,iBAAA,OAAI,CAAC5C,KAAK,CAACwC,KAAA,CAAM,EAACK,OAAO,cAAzBF,yBAAA,uBAAAA,yBAAA,CAAAG,IAAA,CAAAF,iBAAA;MACA,IAAI,CAAC5C,KAAK,CAACmC,MAAM,CAACK,KAAA,EAAO;IAC3B;IAEA,IAAI,CAACF,mBAAmB,CAAC;MAACC,MAAA,EAAQ;WAASzB;IAAG;EAChD;EAEA;EACAC,OAAOD,GAAW,EAAE;IAClB,IAAI,CAACwB,mBAAmB,CAAC;MAACC,MAAA,EAAQ;WAAUzB;IAAG;EACjD;EAEQwB,oBAAoB1B,OAA2D,EAAE;IACvF,IAAI;MAAA2B,MAAA,EAACA,MAAM;MAAAzB,GAAA,EAAEA;IAAG,CAAC,GAAGF,OAAA;IACpB,IAAImC,MAAA,GAAS,IAAI,CAAC/C,KAAK,CAACgD,KAAK,CAAC,GAAG,IAAI,CAAClD,gBAAgB;IAEtD,IAAIyC,MAAA,KAAW,SAAS,IAAI,CAACxC,gBAAgB,EAAE;MAC7C,IAAIkD,UAAA,GAA+B,IAAI,CAACzC,aAAa,CAClD0C,MAAM,CAACR,CAAA,IAAK,CAACK,MAAA,CAAOI,IAAI,CAACC,EAAA,IAAMV,CAAA,CAAE5B,GAAG,KAAKsC,EAAA,CAAGtC,GAAG,GAC/CuC,GAAG,CAACX,CAAA,KAAM;QAAC,GAAGA,CAAC;QAAEN,SAAA,EAAW;MAAS;MACxC,IAAI,CAAC5B,aAAa,GAAGyC,UAAA,CAAWK,MAAM,CAACP,MAAA,EAAQQ,IAAI,CAAC,CAACC,CAAA,EAAGC,CAAA;YAAOC,WAAA,EAAoBC,WAAA;eAArB,CAAC,CAAAD,WAAA,GAAAD,CAAA,CAAEvB,QAAQ,cAAVwB,WAAA,cAAAA,WAAA,GAAc,MAAM,CAAAC,WAAA,GAAAH,CAAA,CAAEtB,QAAQ,cAAVyB,WAAA,cAAAA,WAAA,GAAc;;IACnG,OAAO,IAAIpB,MAAA,KAAW,WAAW,IAAI,CAACxC,gBAAgB;MACpD;MACA,IAAI,CAACS,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC6C,GAAG,CAACX,CAAA;QAC1C,IAAIA,CAAA,CAAE5B,GAAG,KAAKA,GAAA,EACZ,OAAO4B,CAAA,MAEP,OAAO;UAAC,GAAGA,CAAC;UAAEN,SAAA,EAAW;QAAS;MAEtC,QAEA,IAAI,CAAC5B,aAAa,GAAGuC,MAAA;IAGvB,KAAK,IAAIzC,EAAA,IAAM,IAAI,CAACY,aAAa,EAC/BZ,EAAA;EAEJ;EAEA;EACAU,SAAA,EAAW;IACT,KAAK,IAAIQ,KAAA,IAAS,IAAI,CAAChB,aAAa,EAClC,IAAIgB,KAAA,CAAMC,KAAK,EACbD,KAAA,CAAMC,KAAK,CAACmC,KAAK;EAGvB;EAEA;EACA3C,UAAA,EAAY;IACV,KAAK,IAAIO,KAAA,IAAS,IAAI,CAAChB,aAAa,EAClC,IAAIgB,KAAA,CAAMC,KAAK,EACbD,KAAA,CAAMC,KAAK,CAACoC,MAAM;EAGxB;EA1GAC,YAAYlD,OAAyB,EAAE;SAP/BZ,KAAA,GAA0B,EAAE;SAC5BkB,aAAA,GAAiC,IAAI6C,GAAA;IAG7C;IAAkC,KAClCvD,aAAA,GAAkC,EAAE;QAGVwD,yBAAA;IAAxB,IAAI,CAAClE,gBAAgB,GAAG,CAAAkE,yBAAA,GAAApD,OAAA,aAAAA,OAAA,uBAAAA,OAAA,CAASd,gBAAgB,cAAzBkE,yBAAA,cAAAA,yBAAA,GAA6B;QAC7BC,yBAAA;IAAxB,IAAI,CAAClE,gBAAgB,GAAG,CAAAkE,yBAAA,GAAArD,OAAA,aAAAA,OAAA,uBAAAA,OAAA,CAASb,gBAAgB,cAAzBkE,yBAAA,cAAAA,yBAAA,GAA6B;EACvD;AAwGF;AAEA,MAAMtC,2BAAA;EAWJuC,MAAMC,KAAa,EAAE;IACnB,IAAI,CAACC,SAAS,GAAGD,KAAA;IACjB,IAAI,CAACN,MAAM;EACb;EAEAD,MAAA,EAAQ;IACN,IAAI,IAAI,CAACS,OAAO,IAAI,MAClB;IAGFC,YAAA,CAAa,IAAI,CAACD,OAAO;IACzB,IAAI,CAACA,OAAO,GAAG;IACf,IAAI,CAACD,SAAS,IAAIG,IAAA,CAAKC,GAAG,KAAK,IAAI,CAACC,SAAS;EAC/C;EAEAZ,OAAA,EAAS;IACP,IAAI,IAAI,CAACO,SAAS,IAAI,GACpB;IAGF,IAAI,CAACK,SAAS,GAAGF,IAAA,CAAKC,GAAG;IACzB,IAAI,CAACH,OAAO,GAAGK,UAAA,CAAW;MACxB,IAAI,CAACL,OAAO,GAAG;MACf,IAAI,CAACD,SAAS,GAAG;MACjB,IAAI,CAACO,QAAQ;IACf,GAAG,IAAI,CAACP,SAAS;EACnB;EA/BAN,YAAYa,QAAoB,EAAER,KAAa,EAAE;SAJzCM,SAAA,GAA2B;IAKjC,IAAI,CAACL,SAAS,GAAGD,KAAA;IACjB,IAAI,CAACQ,QAAQ,GAAGA,QAAA;EAClB;AA6BF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}